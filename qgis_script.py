# -*- coding: utf-8 -*-
"""qgis_script.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sGJtgtkDKZBjCGgAD3kwcIY3ODVEQrlw

QGIS SCRIPT 
Two main functions i) county_name, and ii) aqua_name

**county_name**

Gets the county based on the address

**aqua_name**

For the aquifer data, given an address, returns its aquifer name by querying the QGIS API if the location is part of the sampling.



<!-- TODO -->
<!-- Add a helper function to find coordinated from an address -->
"""

################################################################################
############################installing packages ################################
################################################################################
!pip install uszipcode
!pip install fiona
!pip install pyproj
!pip install turfpy

# Import necessary libraries 
import os
import fiona
import requests
import urllib.parse
from uszipcode import SearchEngine

# To be store in a database with an endpoint to add
county_list = ['Montgomery','Loudoun','Albemarle','Prince William','Roanoke','Frederick','Spotsylvania','Warren',
               'Franklin','Goochland','Hanover','Carroll','Rockingham','Bedford','Pulaski','Nelson','Shenandoah',
               'Botetourt','Halifax','Floyd','Page','Rockbridge','Accomack','Northampton','Powhatan','Grayson',
               'Amelia','Louisa','Clarke','Northumberland','Giles','Stafford','Fauquier','Buckingham','Nottoway',
               'Wythe','Campbell','Prince George','Fairfax','Chesapeake','Mecklenburg','Culpeper','Madison','Augusta',
               'Rappahannock','Caroline','Orange','Westmoreland','Lunenburg','King George','Amherst','Fluvanna','Greene',
               'Craig','Virginia Beach','Charlotte','Lancaster','Pittsylvania','Essex','Henry','Appomattox','Isle of Wight',
               'King William','New Kent','Gloucester','Chesterfield','Suffolk','Dinwiddie','Lee','Bland','Russell',
               'Charles City','Highland','Patrick','Surry','Henrico','Prince Edward','Richmond County',
               'Southampton','Cumberland','Middlesex','Bath','Tazewell','Alleghany','Mathews','Smyth',
               'King & Queen','Sussex','Brunswick','Greensville','Scott','Dickenson','Wise',
               'James City','Lynchburg City','Buchanan','York','Petersburg','Richmond City','KY-Floyd']

def county_name(zipcode):
	"""
	Computes the name of a county given it's zipcode 

	:param zipcode: the zipcode of the address
	:return: a string (name of the county) or None
	""" 
	search = SearchEngine(simple_zipcode=True) # set simple_zipcode=False to use rich info database
	zipcode_query = search.by_zipcode(str(zipcode))
	zipcode_query_dict = zipcode_query.to_dict()
	county = zipcode_query_dict['county']
	if county is None:
		print('Invalid County')
	else :
		if 'County' in county:
			county = county[:-7]
		if county in county_list:
	  		print('County is County List')
        print(county)
    return county


def address_coordinates(address):

    """
    Computes the long and lat of a given address 

    :param zipcode: the zipcode of the address
    :return: a string (name of the county) or None
    """ 
	  # get url for address
    url = 'https://nominatim.openstreetmap.org/search/' + urllib.parse.quote(address) +'?format=json'
    response = requests.get(url).json()
    lat_long_tup = (response[0]["lat"],response[0]["lon"])
    if lat_long_tup is None:
    	print('Address is not recognize')
    else:
    	print(lat_long_tup)
    return lat_long_tup

################################################################################
#################################local testing##################################
################################################################################
print(county_name(19104)) 
print(county_name(17104)) 
# Counties in list
print(county_name(15062)) 
print(address_coordinates("337 North 40th Street,Philadelphia, PA, 19104"))
print(address_coordinates("2222 Max Meadows, Virginia"))

#  1) Fiona (reading shapefile)
#  2) pyproj (projection management)
#  3) Shapely (geometry)
import itertools
from fiona.crs import from_epsg
from pyproj import Proj, transform
from shapely.geometry import shape,mapping, Point, Polygon, MultiPolygon

# Get the aquifer name from the 
def aq_name(path_to_shp_file):
    """
    Computes the name of a given aquifer given it's shape file 

    :param path_to_shp_file: path to the .shp file for the given aquifer
    :return: a string (name of the aquifer)
    """ 
    str_aqs = path_to_shp_file.split('/')
    str_aq = str(str_ags[1])
    return str_aq   

# ref:  https://gis.stackexchange.com/questions/208546/check-if-a-point-falls-within-a-multipolygon-with-python
# Use a quad tree to store coordinates and name tree 
# find the aquifer name given an address and a dictionary of aquifers along with 
# their coordinates

def contains_coordinate(coordinate, path_to_shp_file):
    """
    checks to see if a given coordinate is within the polygon/multipolygon mapped
    out by a shape file

    :param coordinate: the coordinates/latitude and longtitude of the given point
    :param path_to_shp_file: path to the .shp file for the given aquifer
    :return: a boolean (whether or not the coordinate is in a given shape file)
    """ 
    multipol = fiona.open(path_to_aq_VA_shp)
    multi= multipol.next() # only one feature in the shapefile
    point = Feature(geometry=Point((float(coordinate[1]), float(coordinate[0])))) # create point
    # point = Feature(geometry=Point(((-81), (37)))) # create point
    # print(point)
    point = shape(point['geometry'])
    if point.within(shape(multi['geometry'])):
      return True
    return False 

def contains_address(address, path_to_shp_file):
    """
    checks to see if a given address is within the polygon/multipolygon mapped
    out by a shape file

    :param address: the address of the given point
    :param path_to_shp_file: path to the .shp file for the given aquifer
    :return: a boolean (whether or not the address is in a given shape file)
    """ 
    coordinate = address_coordinates(address)
    # todo: Error checking on the coordinate (it can be none type)
    return contains_coordinate(coordinate, path_to_shp_file)

################################################################################
#################################local testing##################################
################################################################################
path_to_aq_VA_shp = "/content/aq_VA.shp"
#  test
address_one = "337 North 40th Street,Philadelphia, PA, 19104" #not in VA_AQ
address_two = "2222 Max Meadows, Virginia"  #in VA_AQ
address_three = "Honaker, Virginia" #in VA_AQ
address_four = "119 J C Hillman Dr, Honaker, VA 24260" #in VA_AQ
address_five = "1135 Carthage St, Sanford, NC 27330"  #not in VA_AQ
address_six = "11221 New Garden Rd, Honaker, VA 24260"  # in VA_AQ
address_seven = "10300 New Garden Rd, Honaker, VA 24260"  # in VA_AQ


print("address one coords: " + str(address_coordinates(address_one)))
print(contains_address(address_one, path_to_aq_VA_shp))
assert(contains_address(address_one, str(path_to_aq_VA_shp)) == False)
print("address two coords: " + str(address_coordinates(address_two)))
print(contains_address(address_two, str(path_to_aq_VA_shp)))
assert(contains_address(address_two, str(path_to_aq_VA_shp)) == True)
print("address three coords: " + str(address_coordinates(address_three)))
print(contains_address(address_three, str(path_to_aq_VA_shp)))
assert(contains_address(address_three, str(path_to_aq_VA_shp)) == True)
print("address four coords: " + str(address_coordinates(address_four)))
print(contains_address(address_four, str(path_to_aq_VA_shp)))
assert(contains_address(address_four, str(path_to_aq_VA_shp)) == True)
print("address five coords: " + str(address_coordinates(address_five)))
print(contains_address(address_five, str(path_to_aq_VA_shp)))
assert(contains_address(address_five, str(path_to_aq_VA_shp)) == False)
print("address six coords: " + str(address_coordinates(address_six)))
print(contains_address(address_six, str(path_to_aq_VA_shp)))
assert(contains_address(address_six, str(path_to_aq_VA_shp)) == True)
print("address seven coords: " + str(address_coordinates(address_seven)))
print(contains_address(address_seven, str(path_to_aq_VA_shp)))
assert(contains_address(address_seven, str(path_to_aq_VA_shp)) == True)

))################################################################################
############################# Single Polygon code ##############################
################################################################################
# n.b. I should probably create a python dictionary of all the aquafiers and a list of 
# their coordinates and pass this into the aqua_name function
# should be able to do aq_coordinates =  get_aq_dict(path_to_aq_folder)
# aq_coordinates = {} 
# aq_coordinates['VA'] = boundary_coordinated_shp_file("/content/aq_VA.shp")

# from turfpy.measurement import boolean_point_in_polygon
# from geojson import Point, Polygon, Feature

# def aqua_name(address, aq_coordinates):
#   target_coordinates = address_coordinates(address)
#   for aq in aq_coordinates:
#     coordinates = aq_coordinates[aq]  
#     # lons_lats_vect = np.column_stack((lons_vect, lats_vect)) # Reshape coordinates
#     polygon = Polygon(coordinates) # create polygon
#     point = Feature(geometry=Point((float(target_coordinates[1]), float(target_coordinates[0])))) # create point
#     aq_contains_point = boolean_point_in_polygon(point, polygon)
#     print(aq_contains_point) # check if polygon contains point
#     if aq_contains_point:
#       return aq
#   return None

######Debugging############

# multipol = fiona.open(path_to_aq_VA_shp)
# multi= multipol.next() # only one feature in the shapefile
# # point = Feature(geometry=Point((float(coordinate[1]), float(coordinate[0])))) # create point
# points= ([(Feature(geometry=Point((float(-i), float(j))))) for i in range(100) for j in range(100)])
# for i, pt in enumerate(points):
#   point = shape(pt['geometry'])
#   if point.within(shape(multi['geometry'])):
#     print(point)
#     print(i, shape(points[i]['geometry']))